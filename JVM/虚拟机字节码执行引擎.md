# 字节码执行引擎

## 1、运行时栈帧结构

Java虚拟机以方法作为最基本的执行单元，栈帧用于支持虚拟机进行方法调用和方法执行背后的数据结构。

栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。

对于执行引擎来说，只有位于栈顶的方法才是在执行的，称为“当前栈帧”，与其关联的方法称为“当前方法”。

<img src="https://raw.githubusercontent.com/Hipekit/Pic/master/img/20200423205210.png" alt="栈帧的结构" width="50%" height="50%"/>

### 1.1、局部变量表

局部变量表存放方法参数和方法内部定义的变量。

局部变量表的大小在编译期就确定了，被方法的Code属性的max_locals数据项指定。

局部变量表以变量槽`Slot`为最小单位，一个Slot存放32位的数据类型，包括boolean、byte、char、short、int、float、reference和returnAddress类型的数据。对于64位的数据，会以高位对齐的方式分配两个连续的Slot。

> reference是对一个对象实例的引用，可以根据其直接或间接查找到对象在Java堆中数据存放的起始地址或索引，以及对象的数据类型在方法区中的类型信息。

当实例方法被调用时，局部变量表的第0位索引的Slot默认是存放方法所属对象实例的引用，其余参数按参数列表顺序排列，占用从1开始的Slot。之后，在根据方法内部定义的局部变量顺序和作用域来分配其他Slot。

### 1.2、操作数栈
操作数栈是一个后入先出的栈，栈的最大深度在编译时被写到了Code属性的max_stacks数据项中。Javac编译器的数据流分析工作保证了在方法执行的任何时候，栈的深度都不会超过max_stacks的最大值。

Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。

### 1.3、动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所方法的引用，通过这个引用是为了支持方法调用过程中的动态连接。

在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就是以常量池指向方法的符号引用作为参数。这些符号引用的解析分为两种：
* 静态解析：在类加载阶段或者第一次使用的时候转为直接引用
* 动态连接：在每次运行期间都转为直接引用

### 1.4、方法返回地址
当一个方法执行后，只有两种方式可以退出这个方法：正常调用完成和异常调用完成
* 正常调用完成：执行引擎遇到方法返回的字节码指令，这个时候可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定。
* 异常调用完成：在方法执行的过程中遇到了异常，然后这个异常没有在方法提内得到妥善处理（该方法的异常列表没有搜索到匹配的异常处理）。
当方法正常退出时，主调方法的PC计数器的值就可以作为方法返回地址，而异常退出时，返回地址需要通过异常处理器来确定。

## 2、方法调用
方法调用是调用某一个方法，而不是执行该方法的代码。在Class文件的编译期间，一切方法的调用在Class文件中都是符号引用，而不是方法的直接引用。

### 2.1、解析
解析会将Class文件中一部分符号引用转化为直接引用，但这种解析成立的前提是：调用的方法在编译器进行编译时就确定了下来。

在解析阶段能确定唯一调用版本的有静态方法、私有方法、实例构造器、父类方法和被`final`修饰的方法5种，这5种方法在类加载的时候就会把符号引用解析为直接引用，这些方法被称为“非虚方法”。与之相反，其他方法称为“虚方法”。

### 2.2、分派
分派是一种方法调用方式，按分派依据的宗量数可以分为单分派和多分派，两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派。

#### 2.2.1、静态分派
静态分派是指依赖静态类型来决定方法执行版本的分派动作，其最典型的应用表现就是方法重载，静态分派发生在编译期。

```java
class Human{}

class Man extends Human{}

class Woman extends Human{}

public class Test{
    public void sayHello(Human guy){
        System.out.println("hello, guy")
    }

    public void sayHello(Man man){
        System.out.println("hello, man")
    }

    public void sayHello(Woman woman){
        System.out.println("hello, woman")
    }

    public static void main(String[] args){
        Human man = new Man();
        Human woman = new Woman();
        Test test = new Test();
        test.sayHello(man);
        test.sayHello(woman);
    }
}


```
运行结果：
```
hello,guy
hello,guy
```
上面的代码中有三个重载方法，参数各不相同，但是`Man`和`Woman`都是`Human`的子类 ，通过test调用sayHello方法输出都是以Human类型为参数的方法，这是因为man和woman声明的类型都是Human，这个声明类型在编译期是确定的，而这两个对象的实际类型是在运行期才确定的。编译器在编译程序时，并不知道对象的实际类型是什么，而是会把声明类型当作该对象的类型。

#### 2.2.2、动态分派
动态分派与重写很有关联，当子类重写了父类的一个方法时，通过子类实例化父类对象（对象的向上转型），当使用该对象调用同名方法时，调用的是子类重写的方法。之所以会有这样的效果，原因就在于调用方法的invokevirtual指令，这条指令的运行过程大致如下：
1. 找到操作数栈顶的第一个元素所指向对象的实际类型，记作A。
2. 如果在类型A中找到了与常量池中描述符与简单名称相符的方法，则进行权限校验，如果通过则返回这个方法的直接引用；不通过则返回java.lang.IllegalAccessError异常。
3. 否则，按照继承关系从下到上依次对A的父类进行第二步的搜索和校验。
4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodErroe异常。

> 该指令只对方法有效，对于字段而言，哪个类访问的就是哪个类的字段。例如，A、B两个类，B继承A,两个类都有字段data，当`A a = new B();`时，通过`a.data`访问的就是A的字段。

### 2.2.3、单分派和多分派
方法的接收者和方法的参数统称宗量，根据分派基于多少宗量，可以分为单分派和多分派。
* 单分派：根据一个宗量对目标方法进行选择
* 多分派：根据多于一个宗量对目标方法进行选择

在类的编译期（静态分派），选择目标方法的依据有两点：一是对象的静态类型，二是调用方法的参数，因此静态分派是多分派。
在运行期（动态分派），由于方法签名在编译期就已经确定，选择的依据就只有方法参数，因此动态分派是单分派。

### 2.2.4、虚拟机动态分派的实现
一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表。

虚方法表中存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类实现了这个方法，子类虚方法表地址会被替换成指向实际实现方法的地址。

虚方法表在类加载的连接阶段进行初始化，准备类变量初始值后，虚方法表也会被初始化。

## 3、动态类型语言支持

### 3.1、动态类型语言
动态类型语言的特征是它的类型检查是在运行期，而不是在编译期。常用的包括：APL、Clojure、Erlang、Groovy、JavaScript、Lisp、Lua等等。

### 3.2、java.lang.invoke包和invokedynamic指令
java.lang.invoke包提供了一种新的动态确定方法的机制，称为“方法句柄”。方法句柄是对Java中方法的一个强类型的可执行的引用。通过方法句柄可以直接调用该句柄所引用的底层方法。

示例；
```java
public class MethodHandleTest{

    static class ClassA{
        public void println(String s){
            System.out.println(s);
        }
    }

    public static void main(String[] args) throws Throwable{
        Object obj = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA();
        //获取方法句柄，调用println方法
        getPrintMH(obj).invokeExact("icyfenix");
    }

    private static MethodHandle getPrintMH(Object reveiver) throws Throwable{

        //MethodType：代表“方法类型”，包含了方法返回值和具体参数
        MethodType mt = MehtodType.methodType(void.class, String.class);
        //lookup()方法来自于MethodHandles.lookup，这句的作用是在指定的类中查找指定名称的方法句柄
        return lookup().findVirtual(reveiver.getClass(), "println", mt).bindTo(reveiver);
    }
}
```

从某种意义上说，invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条“invoke*”指令方法分派规则完全固化在虚拟机之中的问题，把如何查询目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户有更高的自由。

每一处含有invokedynamic指令的位置都被称为“动态调用点”，这条指令的第一个参数是CONSTANT_invokeDynamic_info常量，可以从该常量中获取引导方法、方法类型和名称。引导方法是固定的参数，并且返回值规定是java.lang.invoke。CallSite对象，这个对象代表类真正要执行的目标方法调用。

invokedynamic指令的主要服务对象并非Java语言，而是其他Java虚拟机之上的其他动态类型语言。

## 4、基于栈的字节码解释执行引擎
Java虚拟机的执行引擎在执行Java代码时有解释执行（通过解释器）和编译执行（通过即时编译器产生本地代码执行）两种选择。

### 4.1、基于栈和寄存器的指令集
Java编译器输出的指令流，基本是一种基于栈的指令集，指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。
基于寄存器的指令集，依赖于寄存器进行工作，主流PC机支持的就是这种指令集架构。

示例：计算“1+1”

基于栈的指令集：
```
iconst_1    //1入栈
iconst_1    //1入栈
iadd        //将栈顶的两个值出栈、相加，结果放入栈顶
istore_0    //将栈顶的值放到局部变量表的第0个Slot中
```

基于寄存器的指令集：
```
mov eax, 1  //将EAX寄存器的值设为1
add eax, 1  //将EAX寄存器的值加1
```

基于栈的指令集和基于寄存器的指令集比较
优点：
* 可移植
* 代码相对紧凑，每个字节就对应一条指令
* 编译器实现更加简单，不需要考虑空间分配的问题
缺点：
* 执行速度相对于寄存器稍慢
* 指令的数量比寄存器的架构多