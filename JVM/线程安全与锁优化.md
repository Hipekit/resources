# 线程安全与锁优化
## 1、线程安全
当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就成这个对象是线程安全的。

### 1.1、Java语言中的线程安全
按照线程安全的“安全程度”由弱到强来排序，可以将数据分为一下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

#### 不可变
Java中，如果多线程共享的数据是一个基本数据类型，在定义时使用final关键字就可以保证它是不可变的。如果共享数据是一个对象，需要对象自行保证其行为不会对其状态产生影响，最简单的方式就是把对象里带有状态的变量都声明为final。Java中的String类的实例，就是一个典型的不可变对象，用户调用它的`subString()`、`replace()`这些方法都是返回一个新的字符串对象。

#### 绝对线程安全
绝对线程安全就是在我们通常意义上说的线程安全的基础上，保证在任何调用方式的时候也是线程安全的。

#### 相对线程安全
相对线程安全就是我们通常意义上说的线程安全，它是保证对这个对象的**单次**操作是线程安全的。对于连续调用，就需要保证绝对线程安全。

#### 线程兼容
线程兼容是指对象本身不是线程安全的，但是可以在调用的时候通过一些同步手段来保证对象在并发环境下是线程安全的。

#### 线程对立
线程对立是指不管调用方是否采取了同步手段，都无法在多线程环境中并发使用代码。这种代码在实际中很少会出现。

### 1.2、线程安全的实现方法
#### 互斥同步
同步是指在多个线程并发方法共享数据时，保证共享数据同一个时刻只会被一个线程使用。

互斥是实现同步的手段，临界区、互斥量和信号量都是互斥的实现方式。

Java中，最基本的互斥同步手段就是`synchronized`关键字，`synchronized`关键字编译后会在同步块前后形成`monitorenter`和`monitorexit`这两个指令。这两个指令都需要一个`reference`类型的参数来指明要锁定和解锁的对象。如果`synchronized`指明了锁定的对象，那`reference`就是这个对象，否则根据修饰的方法类型（实例方法或类方法）来决定是代码所在对象还是对象对应的Class类型。
> `synchronized`同步块对同一个线程是可重入的
> `synchronized`会无条件地阻塞其他线程进入该同步块

JDK5之后，Java类库中提供了`java.util.concurrent`包，其中`java.util.concurrent.locks.Lock接口`，能以非块结构实现互斥同步。重入锁`ReentrantLock`是Lock接口最常见的一种实现，与`synchronized`相比增加了一下高级功能：
* **等待可中断**：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待
* **公平锁**：多个线程在等待同一个锁时，要按照申请锁的时间顺序来依次获得锁。`ReentrantLock`默认是非公平的，但可以指定使用公平锁，公平锁会影响性能。
* **锁绑定多个条件**：一个`ReentrantLock`对象可以同时绑定多个`Condition`对象。在`synchronized`中，锁对象的`wait()`和它的`notify()`或`notifyAll()`配合使用时，如果要和多个条件关联，需要额外添加锁。

> 可重入性是指一个线程能反复进入被它自己锁定的同步块，锁关联一个计数器，每次持有锁计数器值加1，每次释放锁计数器值减1。当计数器值为0时，才会真正释放锁。

#### 非阻塞同步
非阻塞同步是一种乐观并发策略，不会阻塞线程。通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果发生争用，再进行其它的补偿措施，最常用的补偿措施就是不断重试，直到出现没有竞争的数据为止。

#### 无同步方案
要保证线程安全，也并非一定要阻塞或非阻塞同步，如果能让程序不涉及共享数据，那它就不需要任何同步措施保证其正确行。
* **可重入代码**：可以在代码执行的任何时刻中断它，转而去执行另一段代码，在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。
* **线程本地存储**：如果一段代码中所需要的数据必须与其它代码共享，可以将这些共享数据保证在同一个线程中执行，这样无须同步也能保证不会出现数据争用的问题。
> Java中使用java.lang.LocalThread类实现线程本地存储功能

## 2、锁优化
### 2.1、自旋锁与自适应自旋
**自旋锁**是指当一个线程尝试获取一把锁时，如果这把锁已经被其它线程获取，该线程将会循环等待，不断判断是否获取锁成功，直到获取成功。

自旋锁的缺点是占用处理器时间，长时间占用锁会浪费性能。自旋锁的默认自旋次数是10次，可以使用参数`-XX:PreBlockSpin`更改。

**自适应自旋**的自旋时间不是固定的，它根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果同一个锁对象上，自旋等待刚刚获取成功过，并且持有锁的线程正在运行中，那么虚拟机会认为这次很有可能也会成功，进而允许更长的自旋等待时间。如果自旋很少获取锁成功，那虚拟机会直接省略掉自旋过程。

### 2.2、锁消除
锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。